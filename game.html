<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>*-*SterMoe*-*</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000 url('space-bg.jpg') center/cover no-repeat fixed;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            min-height: -webkit-fill-available;
            width: 100vw;
            overflow: hidden;
            touch-action: none;
            font-family: Arial, sans-serif;
            position: fixed;
            top: 0;
            left: 0;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }

        html {
            height: -webkit-fill-available;
        }

        canvas {
            border: 3px solid #0f0;
            width: 100vw;
            height: 100vh;
            height: -webkit-fill-available;
            display: block;
            object-fit: contain;
            background: transparent;
            touch-action: none;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }

        body::before {
            content: '';
            position: absolute;
            inset: 0;
            background: inherit;
            filter: contrast(1.2) brightness(1.1) saturate(1.3);
            z-index: -1;
        }

        .settings-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            background: rgba(0, 255, 0, 0.4);
            border: 3px solid #0f0;
            border-radius: 50%;
            font-size: 35px;
            color: #0f0;
            cursor: pointer;
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
        }

        .settings-btn:active {
            background: rgba(0, 255, 0, 0.7);
            transform: scale(0.95);
        }

        .settings-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2500;
            display: none;
        }

        .settings-overlay.active {
            display: block;
        }

        .settings-menu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 20, 0, 0.95);
            border: 3px solid #0f0;
            border-radius: 15px;
            padding: 20px;
            z-index: 3000;
            display: none;
            min-width: 200px;
        }

        .settings-menu.active {
            display: block;
        }

        .settings-title {
            color: #0f0;
            font-size: 19px;
            text-align: center;
            margin-bottom: 15px;
            font-weight: bold;
        }

        .settings-option {
            background: rgba(0, 255, 0, 0.2);
            border: 2px solid #0f0;
            border-radius: 8px;
            padding: 8px 12px;
            margin: 6px 0;
            color: #0f0;
            font-size: 14px;
            cursor: pointer;
            text-align: center;
            user-select: none;
        }

        .settings-option:active {
            background: rgba(0, 255, 0, 0.5);
        }

        .mobile-controls {
            position: fixed;
            inset: 0;
            display: none;
            z-index: 1000;
            pointer-events: none;
        }

        .shoot-btn {
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
            width: 40px;
            height: 80px;
            background: rgba(255, 0, 0, 0.4);
            border: 2px solid #f00;
            border-radius: 10px;
            font-size: 24px;
            color: #f00;
            pointer-events: all;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        .shoot-btn:active {
            background: rgba(255, 0, 0, 0.7);
            transform: translateY(-50%) scale(0.9);
        }

        .shoot-btn-left {
            left: 10px;
        }

        .shoot-btn-right {
            right: 10px;
        }

        .start-screen {
            position: fixed;
            inset: 0;
            background: #000;
            color: #0f0;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 10000;
            text-align: center;
            padding: 20px;
        }

        .start-screen.hidden {
            display: none;
        }

        .start-title {
            font-size: 48px;
            margin-bottom: 30px;
            font-weight: bold;
        }

        .start-button {
            background: #0f0;
            color: #000;
            border: none;
            border-radius: 15px;
            padding: 20px 40px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            margin: 15px;
            min-width: 250px;
        }

        .start-button:active {
            background: #0a0;
            transform: scale(0.95);
        }

        .start-info {
            font-size: 18px;
            margin-top: 30px;
            color: #8f8;
        }

        .landscape-warning {
            position: fixed;
            inset: 0;
            background: #000;
            color: #0f0;
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 9999;
            text-align: center;
            padding: 20px;
        }

        .landscape-warning-icon {
            font-size: 80px;
            margin-bottom: 20px;
        }

        .landscape-warning-text {
            font-size: 24px;
        }

        @media (max-width: 768px) and (orientation: portrait) {
            .landscape-warning {
                display: flex !important;
            }
        }

        @media (min-width: 769px), (orientation: landscape) {
            .mobile-controls {
                display: block !important;
            }
        }
    </style>
</head>
<body>
    <canvas id="game" width="2560" height="1440"></canvas>

    <button class="settings-btn" id="settingsBtn">‚öôÔ∏è</button>

    <div class="settings-overlay" id="settingsOverlay"></div>

    <div class="settings-menu" id="settingsMenu">
        <div class="settings-title">EINSTELLUNGEN</div>
        <div class="settings-option" id="resumeBtn">‚ñ∂Ô∏è Fortsetzen</div>
        <div class="settings-option" id="restartBtn">üîÑ Neustart</div>
        <div class="settings-option" id="soundBtn">üîä Sound: AN</div>
        <div class="settings-option" id="fullscreenBtn">‚õ∂ Vollbild</div>
    </div>

    <div class="mobile-controls">
        <button class="shoot-btn shoot-btn-left" id="shootBtnLeft">‚óÄÔ∏è</button>
        <button class="shoot-btn shoot-btn-right" id="shootBtnRight">‚ñ∂Ô∏è</button>
    </div>

    <div class="start-screen" id="startScreen">
        <div class="start-title">üöÄ *-*SterMoe*-* üöÄ</div>
        <button class="start-button" id="startButton">SPIEL STARTEN</button>
        <div class="start-info">üì± Halte dein Handy FLACH im Querformat<br>üéÆ Kippe Links/Rechts zum Lenken<br>üî• Links = Linker Laser | Rechts = Rechter Laser<br>üí• Halte gedr√ºckt f√ºr Burst-Laser (3x schnell)</div>
    </div>

    <div class="landscape-warning">
        <div class="landscape-warning-icon">üì±‚Üª</div>
        <div class="landscape-warning-text">Bitte drehe dein Ger√§t ins Querformat!</div>
    </div>

    <script>
        // ==================== GAME CONSTANTS ====================
        const CANVAS = {
            WIDTH: 2560,
            HEIGHT: 1440
        };

        const GAME_CONFIG = {
            ENEMY_SPAWN_INTERVAL: 1500,
            POWERUP_SPAWN_INTERVAL: 8000,
            BOSS_SPAWN_CHANCE: 0.2,
            EXPLOSION_PARTICLES: 20
        };

        const SPEEDS = {
            PLAYER_GYRO: 21.2,
            PLAYER_KEYBOARD: 13.78,
            BULLET: 16,
            ENEMY_NORMAL: 2.1,
            ENEMY_BOSS: 1.5,
            POWERUP: 2.7
        };

        const SIZES = {
            PLAYER_MOBILE: { width: 50, height: 40 },
            PLAYER_PC_MULTIPLIER: 1.955, // 1.15 * 1.7
            ENEMY_NORMAL: 40,
            ENEMY_BOSS: 80,
            POWERUP: 65,
            LASER: { width: 6, height: 25 }
        };

        const POINTS = {
            ENEMY_NORMAL: 10,
            ENEMY_BOSS: 25
        };

        const COLORS = {
            PLAYER: '#0f0',
            PLAYER_COCKPIT: '#8f8',
            PLAYER_ENGINE: '#0ff',
            BOSS_PRIMARY: '#ff6600',
            BOSS_SECONDARY: '#ff9900',
            BOSS_TERTIARY: '#ffaa00',
            BOSS_ENGINE: '#dd6600',
            ENEMY: '#f00',
            LASER_LEFT: '#0ff',
            LASER_RIGHT: '#f0f',
            ICE: '#00ddff',
            FIRE: '#ff6600',
            MAGNET: '#ff00ff',
            ELECTRIC: '#ffff00',
            BOOST: '#00ff00'
        };

        // ==================== GAME STATE ====================
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const isMobile = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);

        const playerSize = isMobile
            ? SIZES.PLAYER_MOBILE
            : {
                width: SIZES.PLAYER_MOBILE.width * SIZES.PLAYER_PC_MULTIPLIER,
                height: SIZES.PLAYER_MOBILE.height * SIZES.PLAYER_PC_MULTIPLIER
            };

        let gameState = {
            player: { x: 1230, y: 1340, ...playerSize },
            secondShip: null, // Zweites Schiff (wingman)
            lasers: [],
            enemies: [],
            powerups: [],
            explosions: [],
            score: 0,
            weaponType: 'normal',
            burstMode: { active: false, count: 0, cooldown: 0 },
            isPaused: false,
            soundEnabled: true,
            gameStarted: false
        };

        // Effect Multipliers
        let effects = {
            playerSpeed: 1,
            enemySpeed: 1,
            invincible: 0
        };

        // Effect Timer IDs for cleanup
        let activeTimers = [];

        // Controls
        let controls = {
            moveLeft: false,
            moveRight: false,
            gyroTilt: 0,
            gyroEnabled: false,
            shootLeft: false,
            shootRight: false
        };

        // ==================== POWER-UP DEFINITIONS ====================
        const POWERUP_TYPES = [
            'ice_slow_self', 'ice_slow_enemies', 'ice_ultra',
            'fire_rapid', 'fire_explosion', 'fire_spread',
            'magnet_pull', 'magnet_shield', 'magnet_wingman',
            'electric_chain', 'electric_stun', 'electric_overcharge',
            'boost_speed', 'boost_triple', 'boost_invincible'
        ];

        const POWERUP_CONFIG = {
            ice_: { color: COLORS.ICE, emoji: '‚ùÑ', textColor: '#fff' },
            fire_: { color: COLORS.FIRE, emoji: 'üî•', textColor: '#ffff00' },
            magnet_: { color: COLORS.MAGNET, emoji: 'üß≤', textColor: '#fff' },
            electric_: { color: COLORS.ELECTRIC, emoji: '‚ö°', textColor: '#000' },
            boost_: { color: COLORS.BOOST, emoji: 'üöÄ', textColor: '#fff' }
        };

        // ==================== UTILITY FUNCTIONS ====================
        function clearActiveTimers() {
            activeTimers.forEach(id => clearTimeout(id));
            activeTimers = [];
        }

        function addTimer(callback, delay) {
            const id = setTimeout(() => {
                callback();
                activeTimers = activeTimers.filter(tid => tid !== id);
            }, delay);
            activeTimers.push(id);
            return id;
        }

        function resetGame() {
            clearActiveTimers();
            gameState = {
                player: { x: 1230, y: 1340, ...playerSize },
                secondShip: null,
                lasers: [],
                enemies: [],
                powerups: [],
                explosions: [],
                score: 0,
                weaponType: 'normal',
                burstMode: { active: false, count: 0, cooldown: 0 },
                isPaused: false,
                soundEnabled: gameState.soundEnabled,
                gameStarted: gameState.gameStarted
            };
            effects = {
                playerSpeed: 1,
                enemySpeed: 1,
                invincible: 0
            };
        }

        // ==================== FULLSCREEN & ORIENTATION ====================
        async function enterFullscreen() {
            const elem = document.documentElement;
            try {
                if (elem.requestFullscreen) await elem.requestFullscreen();
                else if (elem.webkitRequestFullscreen) await elem.webkitRequestFullscreen();
                else if (elem.mozRequestFullScreen) await elem.mozRequestFullScreen();
                else if (elem.msRequestFullscreen) await elem.msRequestFullscreen();

                if (/iPhone|iPad|iPod/.test(navigator.userAgent)) {
                    window.scrollTo(0, 1);
                    setTimeout(() => window.scrollTo(0, 0), 100);
                }
            } catch (err) {
                console.log("Fullscreen error:", err);
            }
        }

        function exitFullscreen() {
            try {
                if (document.exitFullscreen) document.exitFullscreen();
                else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
                else if (document.mozCancelFullScreen) document.mozCancelFullScreen();
                else if (document.msExitFullscreen) document.msExitFullscreen();
            } catch (err) {
                console.log("Exit fullscreen error:", err);
            }
        }

        function lockLandscape() {
            if (screen.orientation?.lock) {
                screen.orientation.lock('landscape').catch(err => {
                    console.log('Orientation lock failed:', err);
                });
            }
        }

        // ==================== GYROSCOPE ====================
        function handleOrientation(event) {
            if (event.beta == null || event.gamma == null) return;

            const isLandscape = window.innerWidth > window.innerHeight;
            let tilt = 0;

            if (isLandscape) {
                // Querformat: atan2(beta, gamma) f√ºr stabiles Links/Rechts-Kippen
                const rollRad = Math.atan2(event.beta, event.gamma);
                tilt = rollRad * (180 / Math.PI);
            } else {
                // Hochformat: Gamma nutzen
                tilt = event.gamma;
            }

            // Normalisieren: -25¬∞ bis +25¬∞ ‚Üí -1 bis +1
            tilt = Math.max(-25, Math.min(25, tilt));
            controls.gyroTilt = tilt / 25;
        }

        function startGyroscope() {
            window.addEventListener('deviceorientation', handleOrientation, true);
            controls.gyroEnabled = true;
            console.log('‚úÖ Gyroscope aktiviert');
        }

        async function enableGyroscope() {
            return new Promise((resolve, reject) => {
                if (typeof DeviceOrientationEvent?.requestPermission === 'function') {
                    DeviceOrientationEvent.requestPermission()
                        .then(state => {
                            if (state === 'granted') {
                                startGyroscope();
                                resolve();
                            } else {
                                reject(new Error('Gyroscope permission denied'));
                            }
                        })
                        .catch(reject);
                } else if (typeof DeviceOrientationEvent !== 'undefined') {
                    startGyroscope();
                    resolve();
                } else {
                    reject(new Error('Gyroscope not supported'));
                }
            });
        }

        // ==================== SETTINGS MENU ====================
        const settingsBtn = document.getElementById('settingsBtn');
        const settingsMenu = document.getElementById('settingsMenu');
        const settingsOverlay = document.getElementById('settingsOverlay');
        const resumeBtn = document.getElementById('resumeBtn');
        const restartBtn = document.getElementById('restartBtn');
        const soundBtn = document.getElementById('soundBtn');
        const fullscreenBtn = document.getElementById('fullscreenBtn');

        function openSettings() {
            gameState.isPaused = true;
            settingsMenu.classList.add('active');
            settingsOverlay.classList.add('active');
        }

        function closeSettings() {
            gameState.isPaused = false;
            settingsMenu.classList.remove('active');
            settingsOverlay.classList.remove('active');
        }

        settingsBtn.addEventListener('click', e => {
            e.stopPropagation();
            openSettings();
        });

        settingsOverlay.addEventListener('click', closeSettings);
        resumeBtn.addEventListener('click', closeSettings);
        restartBtn.addEventListener('click', () => {
            resetGame();
            closeSettings();
        });

        soundBtn.addEventListener('click', () => {
            gameState.soundEnabled = !gameState.soundEnabled;
            soundBtn.textContent = gameState.soundEnabled ? 'üîä Sound: AN' : 'üîá Sound: AUS';
        });

        fullscreenBtn.addEventListener('click', () => {
            document.fullscreenElement ? exitFullscreen() : enterFullscreen();
        });

        // ==================== KEYBOARD CONTROLS ====================
        document.addEventListener('keydown', e => {
            if (e.key === 'Escape') {
                settingsMenu.classList.contains('active') ? closeSettings() :
                document.fullscreenElement ? exitFullscreen() : null;
                return;
            }
            if (e.key === 'p' || e.key === 'P') {
                if (!settingsMenu.classList.contains('active')) openSettings();
                return;
            }
            if (gameState.isPaused) return;
            if (e.key === 'ArrowLeft') controls.moveLeft = true;
            if (e.key === 'ArrowRight') controls.moveRight = true;
            if (e.key === 'a' || e.key === 'A') controls.shootLeft = true;
            if (e.key === 'd' || e.key === 'D') controls.shootRight = true;
        });

        document.addEventListener('keyup', e => {
            if (e.key === 'ArrowLeft') controls.moveLeft = false;
            if (e.key === 'ArrowRight') controls.moveRight = false;
            if (e.key === 'a' || e.key === 'A') controls.shootLeft = false;
            if (e.key === 'd' || e.key === 'D') controls.shootRight = false;
        });

        // ==================== MOBILE CONTROLS ====================
        const shootBtnLeft = document.getElementById('shootBtnLeft');
        const shootBtnRight = document.getElementById('shootBtnRight');

        shootBtnLeft.addEventListener('touchstart', e => {
            e.preventDefault();
            controls.shootLeft = true;
        });

        shootBtnLeft.addEventListener('touchend', e => {
            e.preventDefault();
            controls.shootLeft = false;
        });

        shootBtnRight.addEventListener('touchstart', e => {
            e.preventDefault();
            controls.shootRight = true;
        });

        shootBtnRight.addEventListener('touchend', e => {
            e.preventDefault();
            controls.shootRight = false;
        });

        // ==================== START SCREEN ====================
        const startScreen = document.getElementById('startScreen');
        const startButton = document.getElementById('startButton');

        if (!isMobile) {
            startScreen.classList.add('hidden');
            gameState.gameStarted = true;
        }

        startButton.addEventListener('click', async () => {
            try {
                await enterFullscreen();
                lockLandscape();
                await enableGyroscope();
                startScreen.classList.add('hidden');
                gameState.gameStarted = true;
            } catch (err) {
                console.error('Start error:', err);
                alert('Fehler: ' + err.message);
            }
        });

        // ==================== GAME FUNCTIONS ====================
        function shootLaser(side, fromShip = gameState.player) {
            if (gameState.isPaused) return;

            const laserSize = SIZES.LASER;
            const offsetX = side === 'left' ? fromShip.width * 0.25 : fromShip.width * 0.75;

            gameState.lasers.push({
                x: fromShip.x + offsetX - laserSize.width / 2,
                y: fromShip.y - laserSize.height,
                ...laserSize,
                side: side,
                spread: gameState.weaponType === 'spread'
            });
        }

        function createExplosion(x, y, radius) {
            gameState.explosions.push({
                x, y, radius,
                maxRadius: radius,
                alpha: 1,
                particles: Array.from({ length: GAME_CONFIG.EXPLOSION_PARTICLES }, () => ({
                    x, y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    size: Math.random() * 8 + 4,
                    color: Math.random() > 0.5 ? '#ff6600' : '#ffaa00'
                }))
            });
        }

        function applyPowerUp(type) {
            // K√ÑLTE
            if (type === 'ice_slow_self') {
                effects.playerSpeed = 0.5;
                addTimer(() => effects.playerSpeed = 1, 5000);
            } else if (type === 'ice_slow_enemies') {
                effects.enemySpeed = 0.5;
                addTimer(() => effects.enemySpeed = 1, 10000);
            } else if (type === 'ice_ultra') {
                effects.enemySpeed = 0.2;
                addTimer(() => effects.enemySpeed = 1, 8000);
                gameState.score += 100;
            }
            // FEUER
            else if (type === 'fire_rapid') {
                effects.playerSpeed = 1.5;
                addTimer(() => effects.playerSpeed = 1, 8000);
            } else if (type === 'fire_explosion') {
                gameState.enemies.forEach(e => createExplosion(e.x + e.width/2, e.y + e.height/2, 80));
                gameState.score += gameState.enemies.length * 20;
                gameState.enemies = [];
            } else if (type === 'fire_spread') {
                // SPREAD LASER - Auff√§chern wie Lichtkegel
                gameState.weaponType = 'spread';
                addTimer(() => gameState.weaponType = 'normal', 15000);
            }
            // MAGNET
            else if (type === 'magnet_pull') {
                gameState.score += 150;
            } else if (type === 'magnet_shield') {
                effects.invincible = 300;
            } else if (type === 'magnet_wingman') {
                // WINGMAN - Zweites Schiff f√ºr 45 Sekunden
                if (!gameState.secondShip) {
                    gameState.secondShip = {
                        x: gameState.player.x + 150,
                        y: gameState.player.y,
                        ...playerSize
                    };
                    addTimer(() => {
                        gameState.secondShip = null;
                    }, 45000);
                }
            }
            // STROM
            else if (type === 'electric_chain') {
                gameState.score += gameState.enemies.length * 15;
                gameState.enemies.splice(0, Math.min(5, gameState.enemies.length));
            } else if (type === 'electric_stun') {
                effects.enemySpeed = 0.3;
                addTimer(() => effects.enemySpeed = 1, 6000);
            } else if (type === 'electric_overcharge') {
                effects.playerSpeed = 1.8;
                addTimer(() => effects.playerSpeed = 1, 10000);
            }
            // BOOSTER
            else if (type === 'boost_speed') {
                effects.playerSpeed = 2;
                addTimer(() => effects.playerSpeed = 1, 7000);
            } else if (type === 'boost_triple') {
                effects.playerSpeed = 1.5;
                addTimer(() => effects.playerSpeed = 1, 12000);
            } else if (type === 'boost_invincible') {
                effects.invincible = 500;
                effects.playerSpeed = 1.2;
                addTimer(() => effects.playerSpeed = 1, 10000);
            }
        }

        // ==================== SPAWNERS ====================
        setInterval(() => {
            if (gameState.isPaused) return;
            const isBoss = Math.random() < GAME_CONFIG.BOSS_SPAWN_CHANCE;
            const size = isBoss ? SIZES.ENEMY_BOSS : SIZES.ENEMY_NORMAL;
            gameState.enemies.push({
                x: Math.random() * (isBoss ? 2400 : 2520),
                y: isBoss ? -size : -size,
                width: size,
                height: size,
                health: isBoss ? 2 : 1,
                isBoss
            });
        }, GAME_CONFIG.ENEMY_SPAWN_INTERVAL);

        setInterval(() => {
            if (gameState.isPaused) return;
            gameState.powerups.push({
                x: Math.random() * (CANVAS.WIDTH - SIZES.POWERUP),
                y: -SIZES.POWERUP,
                width: SIZES.POWERUP,
                height: SIZES.POWERUP,
                type: POWERUP_TYPES[Math.floor(Math.random() * POWERUP_TYPES.length)]
            });
        }, GAME_CONFIG.POWERUP_SPAWN_INTERVAL);

        // ==================== DRAW FUNCTIONS ====================
        function drawPlayerShip(x, y, w, h) {
            ctx.save();
            ctx.fillStyle = COLORS.PLAYER;
            ctx.shadowColor = 'rgba(0, 255, 0, 0.6)';
            ctx.shadowBlur = 15;

            ctx.beginPath();
            ctx.moveTo(x + w/2, y);
            ctx.lineTo(x + w, y + h * 0.8);
            ctx.lineTo(x + w * 0.6, y + h);
            ctx.lineTo(x + w * 0.4, y + h);
            ctx.lineTo(x, y + h * 0.8);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = COLORS.PLAYER_COCKPIT;
            ctx.shadowBlur = 5;
            ctx.beginPath();
            ctx.arc(x + w/2, y + h * 0.4, w * 0.15, 0, Math.PI * 2);
            ctx.fill();

            ctx.shadowColor = COLORS.PLAYER_ENGINE;
            ctx.shadowBlur = 20;
            ctx.fillStyle = 'rgba(0, 255, 255, 0.8)';
            ctx.fillRect(x + w * 0.35, y + h * 0.95, w * 0.1, h * 0.08);
            ctx.fillRect(x + w * 0.55, y + h * 0.95, w * 0.1, h * 0.08);

            ctx.restore();
        }

        function drawEnemyShip(x, y, w, h, isBoss) {
            ctx.save();

            if (isBoss) {
                // Boss Design - Orange/Gelb/Rot
                ctx.fillStyle = COLORS.BOSS_PRIMARY;
                ctx.shadowColor = 'rgba(255, 100, 0, 0.8)';
                ctx.shadowBlur = 20;

                // K√∂rper
                ctx.beginPath();
                ctx.moveTo(x + w * 0.5, y + h);
                ctx.lineTo(x + w * 0.65, y + h * 0.4);
                ctx.lineTo(x + w * 0.35, y + h * 0.4);
                ctx.closePath();
                ctx.fill();

                ctx.fillStyle = COLORS.BOSS_SECONDARY;
                ctx.fillRect(x + w * 0.4, y + h * 0.1, w * 0.2, h * 0.4);

                // Fl√ºgel
                ctx.fillStyle = COLORS.BOSS_TERTIARY;
                ctx.beginPath();
                ctx.moveTo(x, y + h * 0.6);
                ctx.lineTo(x + w * 0.4, y + h * 0.7);
                ctx.lineTo(x + w * 0.4, y + h * 0.2);
                ctx.lineTo(x + w * 0.05, y + h * 0.15);
                ctx.closePath();
                ctx.fill();

                ctx.beginPath();
                ctx.moveTo(x + w, y + h * 0.6);
                ctx.lineTo(x + w * 0.6, y + h * 0.7);
                ctx.lineTo(x + w * 0.6, y + h * 0.2);
                ctx.lineTo(x + w * 0.95, y + h * 0.15);
                ctx.closePath();
                ctx.fill();

                // Engine-Pods
                ctx.shadowBlur = 0;
                ctx.fillStyle = COLORS.BOSS_ENGINE;
                ctx.fillRect(x + w * 0.05, y, w * 0.15, h * 0.35);
                ctx.fillRect(x + w * 0.8, y, w * 0.15, h * 0.35);

                // Gl√ºhende Triebwerke
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 25;
                const g1 = ctx.createRadialGradient(x + w * 0.125, y + h * 0.02, 0, x + w * 0.125, y + h * 0.02, w * 0.1);
                g1.addColorStop(0, 'rgba(255, 255, 100, 1)');
                g1.addColorStop(0.5, 'rgba(255, 100, 0, 0.95)');
                g1.addColorStop(1, 'rgba(255, 0, 0, 0)');
                ctx.fillStyle = g1;
                ctx.fillRect(x + w * 0.05, y, w * 0.15, h * 0.1);

                const g2 = ctx.createRadialGradient(x + w * 0.875, y + h * 0.02, 0, x + w * 0.875, y + h * 0.02, w * 0.1);
                g2.addColorStop(0, 'rgba(255, 255, 100, 1)');
                g2.addColorStop(0.5, 'rgba(255, 100, 0, 0.95)');
                g2.addColorStop(1, 'rgba(255, 0, 0, 0)');
                ctx.fillStyle = g2;
                ctx.fillRect(x + w * 0.8, y, w * 0.15, h * 0.1);
            } else {
                // Normaler Gegner - Rotes Dreieck
                ctx.fillStyle = COLORS.ENEMY;
                ctx.shadowColor = 'rgba(255, 0, 0, 0.5)';
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.moveTo(x + w/2, y + h);
                ctx.lineTo(x, y + h * 0.3);
                ctx.lineTo(x + w * 0.3, y);
                ctx.lineTo(x + w * 0.7, y);
                ctx.lineTo(x + w, y + h * 0.3);
                ctx.closePath();
                ctx.fill();
            }

            ctx.restore();
        }

        function drawExplosions() {
            gameState.explosions.forEach((exp, i) => {
                ctx.save();

                const gradient = ctx.createRadialGradient(exp.x, exp.y, 0, exp.x, exp.y, exp.radius);
                gradient.addColorStop(0, `rgba(255, 255, 200, ${exp.alpha})`);
                gradient.addColorStop(0.3, `rgba(255, 150, 0, ${exp.alpha * 0.8})`);
                gradient.addColorStop(0.6, `rgba(255, 100, 0, ${exp.alpha * 0.5})`);
                gradient.addColorStop(1, `rgba(255, 50, 0, 0)`);

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(exp.x, exp.y, exp.radius, 0, Math.PI * 2);
                ctx.fill();

                exp.particles.forEach(p => {
                    ctx.fillStyle = `${p.color}${Math.floor(exp.alpha * 255).toString(16).padStart(2, '0')}`;
                    ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);

                    if (!gameState.isPaused) {
                        p.x += p.vx;
                        p.y += p.vy;
                        p.vy += 0.3;
                    }
                });

                ctx.restore();

                if (!gameState.isPaused) {
                    exp.radius += exp.maxRadius * 0.08;
                    exp.alpha -= 0.04;

                    if (exp.alpha <= 0) {
                        gameState.explosions.splice(i, 1);
                    }
                }
            });
        }

        function drawPowerUp(x, y, w, h, type) {
            ctx.save();
            const cx = x + w/2, cy = y + h/2;
            ctx.shadowBlur = 15;

            const category = Object.keys(POWERUP_CONFIG).find(key => type.startsWith(key));
            if (category) {
                const config = POWERUP_CONFIG[category];
                ctx.fillStyle = config.color;
                ctx.shadowColor = config.color;
                ctx.beginPath();
                ctx.arc(cx, cy, w/2, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = config.textColor;
                ctx.font = `${w * 0.6}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(config.emoji, cx, cy);
            }

            ctx.restore();
        }

        function drawUI() {
            ctx.fillStyle = COLORS.PLAYER;
            ctx.font = '50px Arial';
            ctx.fillText('Score: ' + gameState.score, 30, 80);

            let yOffset = 140;

            if (gameState.weaponType === 'spread') {
                ctx.fillStyle = '#fa0';
                ctx.font = '40px Arial';
                ctx.fillText('üî• SPREAD LASER', 30, yOffset);
                yOffset += 60;
            }

            if (gameState.secondShip) {
                ctx.fillStyle = '#0af';
                ctx.font = '40px Arial';
                ctx.fillText('üöÅ WINGMAN ACTIVE', 30, yOffset);
                yOffset += 60;
            }

            // Steuerungshinweise
            ctx.fillStyle = '#8f8';
            ctx.font = '30px Arial';
            ctx.fillText('A = Links Laser | D = Rechts Laser', CANVAS.WIDTH - 580, 80);
        }

        // ==================== GAME LOOP ====================
        function updateGame() {
            const { player, secondShip } = gameState;

            // Player Movement
            if (controls.gyroEnabled && Math.abs(controls.gyroTilt) > 0.05) {
                player.x += controls.gyroTilt * SPEEDS.PLAYER_GYRO * effects.playerSpeed;
            } else if (!controls.gyroEnabled) {
                if (controls.moveLeft) player.x -= SPEEDS.PLAYER_KEYBOARD * effects.playerSpeed;
                if (controls.moveRight) player.x += SPEEDS.PLAYER_KEYBOARD * effects.playerSpeed;
            }
            player.x = Math.max(0, Math.min(CANVAS.WIDTH - player.width, player.x));

            // Second Ship Movement (folgt dem Player mit Abstand)
            if (secondShip) {
                const targetX = player.x + 120;
                const diff = targetX - secondShip.x;
                secondShip.x += diff * 0.1; // Smooth following
                secondShip.y = player.y;
            }

            // BURST LASER SHOOTING
            if (gameState.burstMode.cooldown > 0) {
                gameState.burstMode.cooldown--;
            }

            // Burst Mode: 3 Laser kurz hintereinander, dann Pause
            if ((controls.shootLeft || controls.shootRight) && gameState.burstMode.cooldown === 0) {
                if (!gameState.burstMode.active) {
                    gameState.burstMode.active = true;
                    gameState.burstMode.count = 0;
                }

                if (gameState.burstMode.count < 3) {
                    if (gameState.burstMode.count === 0 || (Date.now() % 7 === 0)) {
                        if (controls.shootLeft) {
                            shootLaser('left', player);
                            if (secondShip) shootLaser('left', secondShip);
                        }
                        if (controls.shootRight) {
                            shootLaser('right', player);
                            if (secondShip) shootLaser('right', secondShip);
                        }
                        gameState.burstMode.count++;
                    }
                } else {
                    // Nach 3 Sch√ºssen: Pause
                    gameState.burstMode.cooldown = 20;
                    gameState.burstMode.count = 0;
                }
            } else if (!controls.shootLeft && !controls.shootRight) {
                gameState.burstMode.active = false;
                gameState.burstMode.count = 0;
            }

            // Lasers
            gameState.lasers.forEach((laser, i) => {
                if (laser.spread) {
                    // SPREAD LASER - F√§chert sich auf
                    const progress = (CANVAS.HEIGHT - laser.y) / CANVAS.HEIGHT;
                    const maxSpread = CANVAS.WIDTH / 2 - player.x - player.width / 2;
                    const spreadAmount = maxSpread * progress * (laser.side === 'left' ? -1 : 1);
                    laser.x += spreadAmount * 0.08;
                }

                laser.y -= SPEEDS.BULLET * 1.2;
                if (laser.y < -laser.height) gameState.lasers.splice(i, 1);
            });

            // Enemies
            gameState.enemies.forEach((e, i) => {
                e.y += (e.isBoss ? SPEEDS.ENEMY_BOSS : SPEEDS.ENEMY_NORMAL) * effects.enemySpeed;

                gameState.lasers.forEach((laser, li) => {
                    if (laser.x < e.x + e.width && laser.x + laser.width > e.x &&
                        laser.y < e.y + e.height && laser.y + laser.height > e.y) {
                        e.health--;
                        gameState.lasers.splice(li, 1);
                        if (e.health <= 0) {
                            if (e.isBoss) {
                                createExplosion(e.x + e.width/2, e.y + e.height/2, Math.max(e.width, e.height) * 1.8);
                            }
                            gameState.enemies.splice(i, 1);
                            gameState.score += e.isBoss ? POINTS.ENEMY_BOSS : POINTS.ENEMY_NORMAL;
                        }
                    }
                });

                if (e.y > CANVAS.HEIGHT) {
                    if (e.isBoss) {
                        createExplosion(e.x + e.width/2, CANVAS.HEIGHT, Math.max(e.width, e.height) * 1.8);
                    }
                    gameState.enemies.splice(i, 1);
                }
            });

            // PowerUps
            gameState.powerups.forEach((p, i) => {
                p.y += SPEEDS.POWERUP;

                if (player.x < p.x + p.width && player.x + player.width > p.x &&
                    player.y < p.y + p.height && player.y + player.height > p.y) {
                    applyPowerUp(p.type);
                    gameState.powerups.splice(i, 1);
                }

                if (p.y > CANVAS.HEIGHT) gameState.powerups.splice(i, 1);
            });
        }

        function drawLaser(laser) {
            ctx.save();

            const color = laser.side === 'left' ? COLORS.LASER_LEFT : COLORS.LASER_RIGHT;

            // Laser Glow
            ctx.shadowColor = color;
            ctx.shadowBlur = 20;

            // Laser Gradient
            const gradient = ctx.createLinearGradient(laser.x, laser.y, laser.x, laser.y + laser.height);
            gradient.addColorStop(0, color);
            gradient.addColorStop(0.5, color + 'dd');
            gradient.addColorStop(1, color + '66');

            ctx.fillStyle = gradient;
            ctx.fillRect(laser.x, laser.y, laser.width, laser.height);

            // Inner Core
            ctx.fillStyle = '#fff';
            ctx.fillRect(laser.x + laser.width * 0.3, laser.y, laser.width * 0.4, laser.height);

            ctx.restore();
        }

        function renderGame() {
            ctx.clearRect(0, 0, CANVAS.WIDTH, CANVAS.HEIGHT);

            // Main Player Ship
            drawPlayerShip(gameState.player.x, gameState.player.y, gameState.player.width, gameState.player.height);

            // Second Ship (Wingman)
            if (gameState.secondShip) {
                drawPlayerShip(gameState.secondShip.x, gameState.secondShip.y, gameState.secondShip.width, gameState.secondShip.height);
            }

            drawExplosions();

            // Lasers
            gameState.lasers.forEach(laser => drawLaser(laser));

            gameState.enemies.forEach(e => drawEnemyShip(e.x, e.y, e.width, e.height, e.isBoss));
            gameState.powerups.forEach(p => drawPowerUp(p.x, p.y, p.width, p.height, p.type));

            drawUI();
        }

        function gameLoop() {
            if (!gameState.isPaused) {
                updateGame();
            }
            renderGame();
            requestAnimationFrame(gameLoop);
        }

        gameLoop();
    </script>
</body>
</html>
